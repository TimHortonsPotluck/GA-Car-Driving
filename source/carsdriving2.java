/* autogenerated by Processing revision 1277 on 2024-10-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;
import java.util.Comparator;
import java.io.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class carsdriving2 extends PApplet {




//color bgcolor = color(255, 255, 0);
int bgcolor = color(75, 75, 75);


ArrayList<Box> boxes = new ArrayList<Box>();

int popsize = 500;
float inv_popsize = 1f / popsize;

int generation = 1;

ArrayList<CarBad> pop = new ArrayList<CarBad>();
ArrayList<CarBad> nextpop = new ArrayList<CarBad>();

ArrayList<CarBad> best_carbads = new ArrayList<CarBad>();

int time_limit = 1200; // any cars still alive after this # of frames will die

int sim_speed = 1;
int normal_speed = 1;
int fast_speed = 10;

boolean stopped = false;
int counter = 1;

float world = 4; // which set of boxes to load
boolean redraw_on_gen_end = true;
PVector goal_pos;

float[] car_spawn_info;
float goal_y_center;// the center of the goal. the width of the goal is height * .2

PGraphics sim;

static int map_width = 1200;
static int map_height = 800;

static float max_dist = sqrt(map_width * map_width + map_height * map_height);
static float inv_max_dist = 1 / max_dist;


boolean showing_menu = true;
boolean continuous = false;

int graph_pos_x = 600;
int graph_pos_y = 200;
int graph_width = 500;
int graph_height = 500;
FloatList best_dists = new FloatList();
FloatList med_dists = new FloatList();
FloatList avg_dists = new FloatList();

boolean domedianwipeout = true;
boolean alwaysdomedian = true;

Button[] buttons;


 public void settings() {
  //size(map_width + 600, map_height);
  size(map_width, map_height);
  //fullScreen();
}

 public void setup(){
  background(bgcolor);
  //graph = createGraphics(graph_width, graph_height);
  //map = createGraphics(map_width, map_height);
  car_spawn_info = new float[]{50, map_height * .5f - 5, 10, 25, HALF_PI}; // use x = 395 for center
  
  buttons = new Button[5];
  Button watch1gen = new Button(100, 100, 280, 30, false){
    @Override
    public void onClick(){
      println("button watch1gen hit");
      showing_menu = false;
      //doSingleGen(true);
    }
  };
  watch1gen.text = "Watch one generation";
  watch1gen.textsize = 16;
  
  Button watchmultgen = new Button(100, 200, 280, 30, false){
    @Override
    public void onClick(){
      println("button watchcontgen hit");
      continuous = true;
      showing_menu = false;
    }
  };
  watchmultgen.text = "Watch multiple generations";
  watchmultgen.textsize = 16;
  
  Button doquickgen = new Button(100, 300, 280, 30, false){
    @Override
    public void onClick(){
      println("button doquickgen hit");
      doSingleGen(false);
    }
  };
  doquickgen.text = "Do a quick generation";
  doquickgen.textsize = 16;
  
  Button domanyquickgens = new Button(100, 400, 280, 30, true){
    @Override
    public void doToggleAction(){
      println("button domanyquickgens is toggled");
      doSingleGen(false);
    }
  };
  domanyquickgens.text = "Do quick generations continuously";
  domanyquickgens.textsize = 16;
  
  Button savebest = new Button(100, 500, 280, 30, false){
    @Override
    public void onClick(){
      println("button savebest is clicked");
      //if(generation > 1){
      //  best_carbads.get(generation - 2).nn2.serialize("bestfromgen" + str(generation));
      //}
    }
  };
  savebest.text = "Save the best car";
  savebest.textsize = 16;
  
  buttons[0] = watch1gen;
  buttons[1] = watchmultgen;
  buttons[2] = doquickgen;
  buttons[3] = domanyquickgens;
  buttons[4] = savebest;
  
  randomSeed(20);
  //randomSeed(11);
  // seed 6 is good for world 4(1 + 24 rays, {16, 16} hidddens, spawn centered, goal top, 30 boxes max
  // seed 3 is good for world 4 (1 + 8 rays, {6, 6} hiddens), spawn/goal centered, 30 boxes max
  
  
  //toMatrix(getArrayColumn(new float[][]{{0, 1}, {1, 2}, {2, 3}, {3, 4}}, 1)).printMatrix();
  //toMatrix(multiDimSubset(new float[][]{{0, 1}, {1, 2}, {2, 3}, {3, 4}}, 0, 2)).printMatrix();
  //toMatrix(new float[][]{{0, 1}, {1, 2}, {2, 3}, {3, 4}}).printMatrix();
  
  
  drawWorld();
  
  for(int i  = 0; i < popsize; i++){
    CarBad cb = new CarBad(car_spawn_info[0], car_spawn_info[1], car_spawn_info[2], car_spawn_info[3], car_spawn_info[4]);
    //cb.setDefaultColor(color(255));
    //cb.setColor(color(255));
    pop.add(cb);
  }
  
  
}

 public void draw(){
  
  if(showing_menu){
    showMenuScreen();
    
  } else {
    doSingleGen(true);
    
  }
  //doSingleGen(true); /////////////////////////////////////////////
  
}

 public void showMenuScreen(){
  background(bgcolor);
  rect(300, 600, 150, 150);
  
  for(Button b : buttons){
    b.update();
    b.show();
  }
  //println("buttons updated");
  drawGraph();
}

 public void doSingleGen(boolean show){
  //println("here1");
  int t0 = millis();
  int speed = show ? 1 : 10000;
  sim_speed = normal_speed;
  if(!stopped){
    if(show){
      //println("here2");
      background(bgcolor);
      for(Box b : boxes){
        b.show();
        resetMatrix();
      }
    }
    for(int i = 0; i < sim_speed * speed; i++){
      //println(counter);
      if(counter >= time_limit){
        break;
      }
      for(CarBad cb : pop){
        if(!cb.finished && !cb.collided){
          cb.checkCollided(boxes);
          cb.findNearestHits(boxes);
          if(!cb.finished && !cb.collided){
            cb.update();
            if(cb.vel == 0){
              cb.collided = true;
            }
          }
        }
      }
      counter++;
    }
    if(show){
      for(CarBad cb : pop){
        cb.show();
      }
    }
    if(!popAliveOrNotFinished()){
      if(redraw_on_gen_end){
        boxes.clear();
        drawWorld();
      }
      println("gen " + generation + " end");
      nextpop.clear();
      counter = 1;
      generation++;
      float avg_dist = 0;
      float best_dist = MAX_FLOAT;
      for(CarBad cb : pop){
        avg_dist += sqrt(cb.distsq_to_goal) * inv_popsize;
        //println(avg_dist + ", " + cb.dist_travelled + ", " + inv_popsize);
        if(cb.distsq_to_goal < best_dist){
          best_dist = cb.dist_travelled;
        }
      }
      avg_dists.append(avg_dist);
      //println("Avg dist to goal = " + avg_dist);
      //println("Lowest dist to goal = " + sqrt(best_dist));
      getNextGen();
      //for(int i = 0; i < generation - 1; i++){
      //  println(best_carbads.get(i).nn2.layers[0].weights.matrix[0][0]);
      //}
      pop.clear();
      for(CarBad cb : nextpop){
        pop.add(cb);
      }
      if(!continuous){ // if the continuous button was pressed
        showing_menu = true;
      }
    }
    if(show){
      fill(0);
      textSize(20);
      textAlign(LEFT, BOTTOM);
      text("Generation " + str(generation), map_width - 175, map_height - 40);
      text("Counter: " + str(counter), map_width - 175, map_height - 20);
    }
  }
  if(!show){
    println("Time: " + ((millis() - t0) * .001f) + " seconds");
  }
}

 public boolean popAliveOrNotFinished(){
  if(counter >= time_limit){
    return false;
  }
  int count = 0;
  for(CarBad cb : pop){
    if(!cb.collided && !cb.finished){
      count++;
    }
  }
  return (count == 0) ? false : true;
}

 public void drawGraph(){
 
  stroke(255);
  noFill();
  strokeWeight(2);
  //graph_pos_x
  //graph_pos_y
  //graph_height
  //graph_width
  line(graph_pos_x, graph_pos_y, graph_pos_x, graph_pos_y + graph_height);
  line(graph_pos_x, graph_pos_y + graph_height, graph_pos_x + graph_width, graph_pos_y + graph_height);
  line(graph_pos_x, graph_pos_y, graph_pos_x + graph_width, graph_pos_y);
  line(graph_pos_x + graph_height, graph_pos_y, graph_pos_x + graph_width, graph_pos_y + graph_height);
  
  int ytick_size = 50;
  int yticks = (int)(graph_height / ytick_size);
  
  translate(graph_pos_x, graph_pos_y);
  
  
  
  if(best_dists.size() == 0){
    textAlign(CENTER, CENTER);
    textSize(72);
    fill(255);
    text("There's no data yet!", 0, -graph_height / 4, graph_width, graph_height);
    textAlign(LEFT, TOP);
    drawSmiley(graph_width / 2, graph_height *.75f - 20, 150, 255);
  } else {
    float scale =  1500 / yticks;
    float inv_scale = 1 / scale;
    for(int j = 0; j < yticks + 1; j++){
      if(j != 0 && j != yticks){
        strokeWeight(2);
        stroke(100);
        line(0, j * ytick_size, graph_width, j * ytick_size);
      }
      //strokeWeight(7);
      //stroke(color(255, 0, 0));
      //point(0, j * ytick_size);
      //point(graph_width, j * ytick_size);
      textAlign(RIGHT, CENTER);
      text((int)(j * scale), -5, graph_height - j * ytick_size);
    }
    
    
    for(int i = 0; i < generation - 1; i++){
      strokeWeight(2);
      stroke(100);
      float x1 = (i) * graph_width / (generation);
      float x2 = (i + 1) * graph_width / (generation);
      line(x2, 0, x2, graph_height);
      if(i != 0){
        stroke(color(255, 0, 0));
        line(x1, graph_height - inv_scale * ytick_size * best_dists.get(i - 1), x2, graph_height - inv_scale * ytick_size * best_dists.get(i));
        stroke(color(0, 0, 255));
        line(x1, graph_height - inv_scale * ytick_size * med_dists.get(i - 1), x2, graph_height - inv_scale * ytick_size * med_dists.get(i));
        stroke(color(255, 255, 0));
        line(x1, graph_height - inv_scale * ytick_size * avg_dists.get(i - 1), x2, graph_height - inv_scale * ytick_size * avg_dists.get(i));
      }
    }
    strokeWeight(4);
    if(best_dists.size() == 1){
      stroke(color(255, 0, 0));
      point(graph_width * .5f, graph_height - inv_scale * best_dists.get(0) * ytick_size);
      stroke(color(0, 0, 255));
      point(graph_width * .5f, graph_height - inv_scale * med_dists.get(0) * ytick_size);
      stroke(color(255, 255, 0));
      point(graph_width * .5f, graph_height - inv_scale * avg_dists.get(0) * ytick_size);
    }
  }
  
  resetMatrix();
}


 public void drawSmiley(float x, float y, float w, int c){
  noFill();
  stroke(c);
  strokeWeight(2);
  ellipse(x, y, w, w);
  arc(x, y, w / 2, w / 2, QUARTER_PI, QUARTER_PI + HALF_PI);
  ellipse(x - w / 7, y - w / 8, w / 8, w / 8);
  ellipse(x + w / 7, y - w / 8, w / 8, w / 8);
}

 public float truncate(float num, int d){ // f is the number, d is # of decimal places
  float temp = pow(10, d); 
  return floor(num * temp) / temp;
}

 public void keyPressed() {
  if (key == ' ') {
    //stopped = !stopped;
    continuous = false;
  }
}

 public void mouseClicked() {
  if(showing_menu){
    for(Button b : buttons){
      b.update();
      if(b.mouseover){
        if(b.toggle){
          b.clicked = true;
          b.toggled = !b.toggled;
          println("b is clicked");
        } else {
          b.clicked = true;
        }
      }
    }
  }
}

 public void mouseReleased(){
  sim_speed = (sim_speed == normal_speed) ? fast_speed : normal_speed;
}
class Box{
  
  PVector pos;
  float angle;
  PVector[] r_matrix;
  PVector[] r_matrix_T;
  
  PVector size;
  PVector half_size;
  PVector center;
  
  float max_extent_from_center_sq;
  
  PVector[] corners = new PVector[4];
  
  boolean collided = false;
  boolean collidable = true;
  
  int c0 = color(20, 20, 255);
  int c = c0;
  
  Box(float x, float y, float size_x, float size_y, float angle){
    this.pos = new PVector(x, y);
    this.size = new PVector(size_x, size_y);
    this.half_size = this.size.copy().mult(.5f);
    this.angle = angle;
    this.max_extent_from_center_sq = pow(half_size.x + 13 + 5, 2) + pow(half_size.y + 13 + 5, 2);
    this.r_matrix = new PVector[]{new PVector(cos(angle), -sin(angle)), new PVector(sin(angle), cos(angle))};
    this.r_matrix_T = transpose(r_matrix);
    calcCorners();
    this.center = (pos.copy().add(corners[3])).mult(.5f);
  }
  
   public void update(){
    //calcCorners();
  }
  
   public void calcCorners(){
    this.corners[0] = new PVector(pos.x, pos.y); // this is always the case
    if(angle == 0){
      this.corners[1] = new PVector(pos.x + size.x, pos.y);
      this.corners[2] = new PVector(pos.x, pos.y + size.y);
      this.corners[3] = new PVector(pos.x + size.x, pos.y + size.y);
    } else {
      this.corners[1] = vecMatMult2D(r_matrix_T, new PVector(size.x, 0)).add(pos);
      this.corners[2] = vecMatMult2D(r_matrix_T, new PVector(0, size.y)).add(pos);
      this.corners[3] = vecMatMult2D(r_matrix_T, new PVector(size.x, size.y)).add(pos);
    }
  }
  
  
   public boolean checkBoxCollision(Box self, Box other){
    for(int i = 0; i < 4; i++){
      if(checkCollisionOA(other.corners[i].x, other.corners[i].y, self)){
        return true;
      }
    }
    return false;
  }
  
   public boolean checkCollisionAA(float px, float py, PVector pos_, PVector size_){ // coords of point, box position/size
    return !(px <= pos_.x || px >= pos_.x + size_.x || py <= pos_.y || py >= pos_.y + size_.y);
  }
  
   public boolean checkCollisionOA(float px, float py, Box self){
    PVector p = new PVector(px, py).copy().sub(self.corners[0]);
    PVector _p = vecMatMult2D(self.r_matrix, p);
    return checkCollisionAA(_p.x, _p.y, new PVector(0, 0), self.size);
  }
  
  
   public PVector vecMatMult2D(PVector[] mat, PVector vec){
    PVector p = new PVector();
    p.set(mat[0].copy().mult(vec.x).add(mat[1].copy().mult(vec.y)));
    return p;
  }
  
   public PVector[] matMatMult2D(PVector[] mat1, PVector[] mat2){
    PVector[] m = new PVector[2];
    PVector[] mat1_T = transpose(mat1);
    m[0] = new PVector(mat2[0].dot(mat1_T[0]), mat2[0].dot(mat1_T[1]));
    m[1] = new PVector(mat2[1].dot(mat1_T[0]), mat2[1].dot(mat1_T[1]));
    return m;
  }
  
   public PVector[] matPower2D(PVector[] mat, int p){ // raise a matrix to a power
    PVector[] temp = mat;
    for(int i = 0; i < p - 1; i++){
      temp = matMatMult2D(temp, mat);
    }
    return temp;
  }
  
   public PVector[] transpose(PVector[] mat){
    return new PVector[]{new PVector(mat[0].x, mat[1].x), new PVector(mat[0].y, mat[1].y)};
  }
  
   public void setAngle(float a){
    angle = a;
    r_matrix = new PVector[]{new PVector(cos(a), -sin(a)), new PVector(sin(a), cos(a))};
    this.r_matrix_T = transpose(r_matrix);
    calcCorners();
  }
  
   public void addAngle(float a){
    angle += a;
    r_matrix = new PVector[]{new PVector(cos(angle), -sin(angle)), new PVector(sin(angle), cos(angle))};
    this.r_matrix_T = transpose(r_matrix);
    calcCorners();
  }
  
   public void setColor(int c){
    this.c = c;
  }
  
   public void setDefaultColor(int c){
    this.c0 = c;
  }
  
   public void resetColor(){
    this.c = c0;
  }
  
   public void show(){
    if(!collided){
      fill(c);
    } else {
      fill(color(255, 0, 0));
    }
    noStroke();
    //stroke(0);
    strokeWeight(2);
    translate(pos.x, pos.y);
    rotate(angle);
    rect(0, 0, size.x, size.y);
    resetMatrix();
    //stroke(0);
    //strokeWeight(5);
    //for(int i = 0; i < 4; i++){
    //  point(corners[i].x, corners[i].y);
    //}
    
    //translate(center.x, center.y);
    //noFill();
    //strokeWeight(2);
    //ellipse(0, 0, 2 * sqrt(max_extent_from_center_sq), 2 * sqrt(max_extent_from_center_sq));
    //resetMatrix();
    
  }
   public void show(PGraphics pg){
    pg.beginDraw();
    if(!collided){
      pg.fill(c);
    } else {
      pg.fill(color(255, 0, 0));
    }
    pg.noStroke();
    //stroke(0);
    pg.strokeWeight(2);
    pg.translate(pos.x, pos.y);
    pg.rotate(angle);
    pg.rect(0, 0, size.x, size.y);
    pg.resetMatrix();
    //stroke(0);
    //strokeWeight(5);
    //for(int i = 0; i < 4; i++){
    //  point(corners[i].x, corners[i].y);
    //}
    
    //translate(center.x, center.y);
    //noFill();
    //strokeWeight(2);
    //ellipse(0, 0, 2 * sqrt(max_extent_from_center_sq), 2 * sqrt(max_extent_from_center_sq));
    //resetMatrix();
    pg.endDraw();
  }
}
class Button{
  
  PVector pos;
  PVector size;
  PVector half_size;
  PVector center;
  
  boolean toggle;
  
  boolean mouseover = false;
  boolean clicked = false;
  boolean toggled = false;
  
  int c0 = color(100, 100, 255);
  int c_over = color(150, 150, 255);
  int c_tog = color(0, 0, 100);
  int c = c0;
  
  String text = "";
  int textsize = 10;
  
  int textc0 = color(0);
  int textc_tog = color(255);
  int textc = textc0;
  
  Button(float x, float y, float size_x, float size_y, boolean toggle){
    this.pos = new PVector(x, y);
    this.size = new PVector(size_x, size_y);
    this.half_size = this.size.copy().mult(.5f);
    this.center = pos.copy().add(half_size);
    this.toggle = toggle;
  }
  
   public void update(){
    mouseover = checkMouseOver();
    c = c0;
    if(clicked){
      onClick();
    }
    if(toggled){
      doToggleAction();
    }
    clicked = false;
  }
  
   public boolean checkMouseOver(){
    return !(mouseX <= pos.x || mouseX >= pos.x + size.x || mouseY <= pos.y ||mouseY >= pos.y + size.y);
  }
  
  public void onMouseOver(){
    
    
    
  }
  
  public void onClick(){
    
    
    
  }
  
  public void doToggleAction(){
    
    
  }
  
   public void show(){
    textc = textc0;
    if(mouseover){
      c = c_over;
    }
    if(toggled){
      c = c_tog;
      textc = textc_tog;
    }
    fill(c);
    noStroke();
    rect(pos.x, pos.y, size.x, size.y);
    fill(textc);
    textSize(textsize);
    textAlign(CENTER, CENTER);
    text(text, pos.x, pos.y - (textsize / 10), size.x, size.y);
    textAlign(LEFT, TOP);
  }
  
  
  
  
  
  
}
class Car extends Box{
  
  PVector vel;
  PVector acc;
  PVector dir;
  
  float engine_max = .25f;
  float engine_fraction = 0;
  boolean pedal_down = false;
  
  float brake_max = .1f;
  boolean brake_down = false;
  
  
  float turning = 0; // -1 = left, 1 = right, 0 = none
  float wheel_turn_max = .8f;
  PVector world_wheel_dir;
  float wheel_turn_angle = 0;
  float turn_rate = .05f;
  float turn_radius = 100;
  
  float angvel = 0;
  float angacc = 0;
  
  
  Car(float x, float y, float size_x, float size_y, float angle){
    super(x, y, size_x, size_y, angle);
    this.vel = new PVector(0, 0);
    this.acc = new PVector(0, 0);
    this.half_size = this.size.copy().mult(.5f);
    this.r_matrix = new PVector[]{new PVector(cos(angle), -sin(angle)), new PVector(sin(angle), cos(angle))};
    this.r_matrix_T = transpose(r_matrix);
    updateCarInfo();
    
  }
  
   public void updateCarInfo(){
    findDir();
    findWorldWheelDir();
    calcCornersCar();
  }
  
   public void update(){
    
    if(pedal_down){
      //engine_fraction = 1;
    } else {
      //engine_fraction = 0;
    }
    
    if(turning != 0){
      turn(turning);
    } else {
      wheelReturn();
    }
    
    acc.set(world_wheel_dir.copy().normalize().mult(engine_max * engine_fraction));
    
    vel.limit(5);
    acc.sub(vel.copy().mult(vel.mag()*.005f));
    if(brake_down){
      acc.sub(vel.copy().normalize().mult(brake_max));
      acc.limit(vel.mag());
    }
    
    vel.add(acc);
    pos.add(vel);
    addAngle(vel.mag() * wheel_turn_angle / turn_radius);
    pedal_down = false;
    updateCarInfo();
  }
  
   public void calcCornersCar(){
    if(angle == 0){
      this.corners[0] = new PVector(pos.x, pos.y);
      this.corners[1] = new PVector(pos.x + size.x, pos.y);
      this.corners[2] = new PVector(pos.x, pos.y + size.y);
      this.corners[3] = new PVector(pos.x + size.x, pos.y + size.y);
    } else {
      this.corners[0] = vecMatMult2D(r_matrix_T, new PVector(-half_size.x, -half_size.y)).add(pos).copy().add(half_size);
      this.corners[1] = vecMatMult2D(r_matrix_T, new PVector(half_size.x, -half_size.y)).add(pos).copy().add(half_size);
      this.corners[2] = vecMatMult2D(r_matrix_T, new PVector(-half_size.x, half_size.y)).add(pos).copy().add(half_size);
      this.corners[3] = vecMatMult2D(r_matrix_T, new PVector(half_size.x, half_size.y)).add(pos).copy().add(half_size);
    }
  }
  
   public void findDir(){
    this.dir = r_matrix_T[1].copy().mult(-1);
  }
  
   public void findWorldWheelDir(){
    this.world_wheel_dir = vecMatMult2D(r_matrix_T, PVector.fromAngle(wheel_turn_angle - HALF_PI));
  }
  
   public void setEngineFrac(float f){
    engine_fraction = constrain(f, 0, 1);
  }
  
   public void addEngineFrac(float f){
    engine_fraction = constrain(engine_fraction + f, 0, 1);
  }
  
   public void turn(float d){ // d = -1 or 1
    wheel_turn_angle = constrain(wheel_turn_angle + d * turn_rate, -wheel_turn_max, wheel_turn_max);
    //println("!!!!!" + wheel_turn_angle);
  }
  
   public void turnRight(){
    wheel_turn_angle = constrain(wheel_turn_angle + turn_rate, -wheel_turn_max, wheel_turn_max);
    println("turning right " + wheel_turn_angle);
  }
  
   public void turnLeft(){
    wheel_turn_angle = constrain(wheel_turn_angle - turn_rate, -wheel_turn_max, wheel_turn_max);
    println("turning left " + wheel_turn_angle);
  }
  
   public void wheelReturn(){
    if(wheel_turn_angle > 0){
      wheel_turn_angle = constrain(wheel_turn_angle - turn_rate, 0, wheel_turn_max);
    } else if(wheel_turn_angle < 0){
      wheel_turn_angle = constrain(wheel_turn_angle + turn_rate, -wheel_turn_max, 0);
    }
  }
  
   public void setAngle(float a){
    angle = a;
    r_matrix = new PVector[]{new PVector(cos(a), -sin(a)), new PVector(sin(a), cos(a))};
    this.r_matrix_T = transpose(r_matrix);
    updateCarInfo();
  }
  
   public void addAngle(float a){
    angle += a;
    r_matrix = new PVector[]{new PVector(cos(angle), -sin(angle)), new PVector(sin(angle), cos(angle))};
    this.r_matrix_T = transpose(r_matrix);
    updateCarInfo();
  }
   public void show(){
    if(!collided){
      fill(c);
    } else {
      fill(color(255, 0, 0));
    }
    
    noStroke();
    //translate(pos.x, pos.y);
    //rotate(angle);
    //rect(0, 0, size.x, size.y);
    translate(pos.x + half_size.x, pos.y + half_size.y);
    rotate(angle);
    rect(-half_size.x, -half_size.y, size.x, size.y);
    noFill();
    stroke(255);
    strokeWeight(1);
    triangle(-half_size.x, half_size.y, half_size.x, half_size.y, 0, -half_size.y);
    resetMatrix();
    stroke(color(0, 255, 0));
    strokeWeight(5);
    for(int i = 0; i < 4; i++){
      //point(corners[i].x, corners[i].y);
    }
    noStroke();
    fill(color(0, 155, 205));
    for(int i = 0; i < 4; i++){
      translate(corners[i].x, corners[i].y);
      if(i <= 1){
        rotate(wheel_turn_angle);
      }
      rotate(angle);
      rect(-3, -6, 6, 12);
      resetMatrix();
    }
    strokeWeight(2);
    stroke(color(255, 0, 255));
    translate(pos.x + half_size.x, pos.y + half_size.y);
    line(-dir.x * 10, -dir.y * 10,  dir.x * 30, dir.y * 30);
    
  }
}
class CarBad extends Box{
  
  float vel;
  //float acc;
  float max_vel = 5;
  float inv_max_vel = 1 / max_vel;
  
  float acc;
  PVector half_size;
  PVector dir;
  
  float engine_max = .25f;
  float engine_fraction = 0;
  boolean pedal_down = false;
  
  float brake_max = .1f;
  boolean brake_down = false;
  
  int turning = 0; // -1 = left, 1 = right, 0 = none
  int last_turning = turning;
  
  float turn_rate = .05f;
  float wheel_turn_angle = 0;
  float wheel_turn_max = .05f;
  
  boolean finished = false;
  
  boolean equal_dist_angle_rays = false;
  
  PVector[] rays = new PVector[1 + 16];
  PVector[] ray_endpoints = new PVector[rays.length];
  float[] ray_dists = new float[rays.length];
  float[] ray_dists_norm = new float[rays.length]; // normalized to be between 0 and 1
  
  float max_dist = carsdriving2.max_dist;//sqrt(map_width * map_width + map_height * map_height);
  float inv_max_dist = carsdriving2.inv_max_dist;//1 / max_dist;
  float fitness;
  float fitness_not_norm;
  float[] fitness_w_index; // array with fitness and index
  int num_dir_changes = 0; // number of times the steering changes direction
  
  float dist_travelled = 0;
  float distsq_to_goal = MAX_FLOAT;
  
  NeuralNetwork2 nn2;
  float[] controls;
  
  int control_box_pos = 0;
  boolean show_rays = false;
  
  int alpha = 15;
  
  int c0 = color(255);
  int c = c0;
  
  CarBad(float x, float y, float size_x, float size_y, float angle){
    super(x, y, size_x, size_y, angle);
    this.vel = 0;
    this.acc = 0;
    this.half_size = this.size.copy().mult(.5f);
    this.r_matrix = new PVector[]{new PVector(cos(angle), -sin(angle)), new PVector(sin(angle), cos(angle))};
    this.r_matrix_T = transpose(r_matrix);
    for(int i = 0; i < rays.length; i++){
      this.ray_endpoints[i] = new PVector(max_dist, max_dist);
    }
    int inodes = (world == 2) ? rays.length + 1: rays.length + 1 + 2; // world 4 has extra for distance
    this.nn2 = new NeuralNetwork2(inodes, new int[]{16, 16}, 6, .1f); // +1 is for vel
    this.controls = new float[nn2.Onodes];
    updateCarInfo();
  }
  
  CarBad(float x, float y, float size_x, float size_y, float angle, NeuralNetwork2 nn2){
    super(x, y, size_x, size_y, angle);
    this.vel = 0;
    this.acc = 0;
    this.half_size = this.size.copy().mult(.5f);
    this.r_matrix = new PVector[]{new PVector(cos(angle), -sin(angle)), new PVector(sin(angle), cos(angle))};
    this.r_matrix_T = transpose(r_matrix);
    for(int i = 0; i < rays.length; i++){
      this.ray_endpoints[i] = new PVector(max_dist, max_dist);
    }
    this.nn2 = nn2;
    this.controls = new float[nn2.Onodes];
    updateCarInfo();
  }
  
   public void updateCarInfo(){
    updateCarDirs();
    calcCornersCar();
  }
  
   public void updateCarDirs(){
    findDir();
    findRayDirs();
  }
  
   public void update(){
    checkFinished();
    
    controls = nn2Controls(); // this lets the nn set the engine/brake/steering
    if(turning != last_turning){
      num_dir_changes++;
    }
    
    
    acc = engine_max * engine_fraction;
    float friction = .007f;
    acc -= vel * .005f;
    
    if(!pedal_down){
      acc -= friction;
      acc = constrain(acc, -abs(vel), 0);
    }
    if(brake_down){
      acc -= brake_max;
      acc = constrain(acc, -abs(vel), 0);
    }
    //vel.add(dir.copy().mult(acc));
    vel += acc;
    vel = constrain(vel, 0, max_vel);
    pos.add(dir.copy().mult(vel));
    //wheel_turn_angle = constrain(wheel_turn_angle + turning * turn_rate, -wheel_turn_max, wheel_turn_max);
    if(abs(vel) > 0){
      addAngle(turn_rate * turning * calcTurnFraction(vel));
    }
    last_turning = turning;
    calcCornersCar(); // we don't want to update the angles if we don't have to
    //updateCarInfo(); // so we only do the corners unless we rotate
    dist_travelled += vel * .1f; // * .1 to keep it from getting too large in the fitness calculation
    distsq_to_goal = pos.copy().sub(goal_pos).magSq();
  }
  
   public float calcTurnFraction(float v){
    return (v * .5f / (max_vel * sq(max_vel))) * sq(3 * max_vel - 2 * v);
  }
  
   public float[] nn2Controls(){
    float[] inputs;
    if(world == 2){
      inputs = concat(ray_dists_norm, new float[]{vel * inv_max_vel});
    } else {
      PVector goal_dist = goal_pos.copy().sub(pos).mult(inv_max_dist);
      inputs = concat(concat(ray_dists_norm, new float[]{vel * inv_max_vel}), subset(goal_dist.array(), 0, 2));
    }
    float[] _controls = toArray(nn2.check(toMatrix(inputs)));
    if(nn2.Onodes == 2){
      //controls[0] is the acc/brake, controls[1] is steering
      if(_controls[0] < .45f){
        setEngineFrac(0);
        pedal_down = false;
        brake_down = true;
      } else if(_controls[0] >= .45f && _controls[0] < .55f){
        setEngineFrac(0);
        pedal_down = false;
        brake_down = false;
      } else if(_controls[0] >= .55f){
        setEngineFrac(1);
        pedal_down = true;
        brake_down = false;
      }
      
      if(_controls[1] < .45f){
        turning = -1;
      } else if(_controls[1] >= .45f && _controls[1] < .55f){
        turning = 0;
      } else if(_controls[1] >= .55f){
        turning = 1;
      }
      
    } else if(nn2.Onodes == 6){
      float[] drive_controls = subset(_controls, 0, 3);
      float[] dir_controls = subset(_controls, 3);
      float drivemax = max(drive_controls);
      float dirmax = max(dir_controls); 
      if(drive_controls[0] == drivemax){
        setEngineFrac(0);
        pedal_down = false;
        brake_down = true;
      } else if(drive_controls[1] == drivemax){
        setEngineFrac(0);
        pedal_down = false;
        brake_down = false;
      } else if(drive_controls[2] == drivemax){
        setEngineFrac(1);
        pedal_down = true;
        brake_down = false;
      }
      
      if(dir_controls[0] == dirmax){
        turning = -1;
      } else if(dir_controls[1] == dirmax){
        turning = 0;
      } else if(dir_controls[2] == dirmax){
        turning = 1;
      }
    }
    return _controls;
  }
  
   public void calcCornersCar(){
    if(angle == 0){
      this.corners[0] = new PVector(pos.x, pos.y);
      this.corners[1] = new PVector(pos.x + size.x, pos.y);
      this.corners[2] = new PVector(pos.x, pos.y + size.y);
      this.corners[3] = new PVector(pos.x + size.x, pos.y + size.y);
    } else {
      this.corners[0] = vecMatMult2D(r_matrix_T, new PVector(-half_size.x, -half_size.y)).add(pos).copy().add(half_size);
      this.corners[1] = vecMatMult2D(r_matrix_T, new PVector(half_size.x, -half_size.y)).add(pos).copy().add(half_size);
      this.corners[2] = vecMatMult2D(r_matrix_T, new PVector(-half_size.x, half_size.y)).add(pos).copy().add(half_size);
      this.corners[3] = vecMatMult2D(r_matrix_T, new PVector(half_size.x, half_size.y)).add(pos).copy().add(half_size);
    }
  }
  
   public void findDir(){
    this.dir = r_matrix_T[1].copy().mult(-1);
  }
  
   public void findRayDirs(){
    
    rays[0] = dir;
    if(equal_dist_angle_rays){
      if(rays.length != 1){
        float ray_angle_diff = radians(180 / (rays.length - 1));
        PVector[] ray_r_matrix = new PVector[]{new PVector(cos(ray_angle_diff), -sin(ray_angle_diff)), new PVector(sin(ray_angle_diff), cos(ray_angle_diff))};
        PVector[] ray_r_matrix_T = transpose(ray_r_matrix);
        
        for(int i = 1; i < 1 + (rays.length - 1) / 2; i++){
          rays[2 * i] = vecMatMult2D(matPower2D(ray_r_matrix, i), dir);
          rays[2 * i - 1] = vecMatMult2D(matPower2D(ray_r_matrix_T, i), dir);
        }
      }
    } else {
      if(rays.length != 1){
        //println(angle);
        int a = 20;
        float max_angle_func = angle_func((rays.length - 1) / 2, a);
        float inv_max_angle_func = 1/ max_angle_func;
        for(int i = 0; i < rays.length; i++){
          rays[i] = PVector.fromAngle(angle + angle_func(i - (rays.length - 1) / 2, a) * inv_max_angle_func * HALF_PI - HALF_PI);
        }
      }
    }
      
  }
  
   public float angle_func(int x, int a){
    return x * x * x + a * x;
  }
  
   public void checkCollided(ArrayList<Box> boxes){
    for(Box b : boxes){
      if(b.collidable){
        float dist_sq = pos.copy().sub(b.center).magSq();
        if(dist_sq <= b.max_extent_from_center_sq){
          if(checkBoxCollision(this, b)){
            collided = true;
          } else if (b.checkBoxCollision(b, this)){
            collided = true;
          }
        }
      }
    }
  }
  
   public void checkFinished(){
    if(pos.x >= map_width - 10){
      finished = true;
    }
  }
  
   public void findNearestHits(ArrayList<Box> boxes){
    for(int i = 0; i < rays.length; i++){
      //int lowest_index;
      int lowest_index = MAX_INT;
      float min = max_dist;
      FloatList all_dists = new FloatList();
      for(Box b : boxes){
        float d = checkRayHit(rays[i], b);
        all_dists.append(d);
        if(d < min){
          min = d;
          lowest_index = boxes.indexOf(b);
        }
      }
      if(lowest_index == MAX_INT){
        ray_dists[i] = max_dist;
      } else {
        ray_dists[i] = all_dists.get(lowest_index);
      }
      ray_dists_norm[i] = min(ray_dists[i], 500) * .002f; //ray_dists[i] * inv_max_dist;
      //println(test_index);
      //println(min);
      //println(all_dists);
      //all_dists.sort();
      //lowest_index = Arrays.binarySearch(all_dists.array(), min);
      //ray_dists[i] = all_dists.get(lowest_index);
    }
  }
  
   public float checkRayHit(PVector ray_dir, Box box){
    PVector origin = pos.copy().add(half_size);
    
    float tmin = 0;
    float tmax = MAX_FLOAT;
    PVector delta = box.pos.copy().sub(origin);
    
    PVector xaxis = box.r_matrix_T[0];
    PVector yaxis = box.r_matrix_T[1];
    float ey = PVector.dot(delta, yaxis);
    float ex = PVector.dot(delta, xaxis);
    float fy = PVector.dot(ray_dir, yaxis);
    float fx = PVector.dot(ray_dir, xaxis);
    float gy = 1 / fy;
    float gx = 1 / fx;
    
    float t1 = (ex) * gx;
    float t2 = (ex + box.size.x) * gx;
    
    if(t1 > t2){
      float w = t1;
      t1 = t2;
      t2 = w;
    }
    if(t2 < tmax){
      tmax = t2;
    }
    if(t1 > tmin){
      tmin = t1;
    }
    
    t1 = (ey) * gy; // doing the ys now
    t2 = (ey + box.size.y) * gy;
    if(t1 > t2){
      float w = t1;
      t1 = t2;
      t2 = w;
    }
    if(t2 < tmax){
      tmax = t2;
    }
    if(t1 > tmin){
      tmin = t1;
    }
    
    //stroke(0);
    //strokeWeight(2);
    //fill(color(0, 255, 0));
    //float xmin = origin.x + ray_dir.x * tmin;
    //float xmax = origin.x + ray_dir.x * tmax;
    //line(xmin, 0, xmin, height);
    //line(xmax, 0, xmax, height);
    //float ymin = origin.y + ray_dir.y * tmin;
    //float ymax = origin.y + ray_dir.y * tmax;
    //line(0, ymin, width, ymin);
    //line(0, ymax, width, ymax);    
    
    if(tmax < tmin){
      //fill(color(255, 0, 0));
      //ellipse(xmin, ymin, 10, 10);
      return max_dist;
    }
    //ellipse(xmin, ymin, 10, 10);
    //fill(0);
    //ellipse(xmax, ymax, 10, 10);
    return tmin;
  }
  
   public void setEngineFrac(float f){
    engine_fraction = constrain(f, 0, 1);
  }
  
   public void addEngineFrac(float f){
    engine_fraction = constrain(engine_fraction + f, 0, 1);
  }
  
   public void setAngle(float a){
    angle = a;
    r_matrix = new PVector[]{new PVector(cos(a), -sin(a)), new PVector(sin(a), cos(a))};
    this.r_matrix_T = transpose(r_matrix);
    updateCarInfo();
  }
  
   public void addAngle(float a){
    angle += a;
    r_matrix = new PVector[]{new PVector(cos(angle), -sin(angle)), new PVector(sin(angle), cos(angle))};
    this.r_matrix_T = transpose(r_matrix);
    updateCarInfo();
  }
  
   public void mutateNN(float ma, float mc){ // ma = mutate amt, mc = mutation chance per weight/bias
    nn2.mutate(ma, mc);
  }
  
   public void crossover(CarBad parent){
    nn2.crossover(parent.nn2);
  }
  
   public NeuralNetwork2 copyNN(){
    return nn2.copyNN();
  }
  
   public void show(){
    resetMatrix();
    if(collided){
      fill(color(255, 50, 50), alpha * 3);
    } else if(finished){
      fill(color(0, 255, 0), alpha);
    } else {
      fill(c, alpha);
    }
    
    noStroke();
    translate(pos.x + half_size.x, pos.y + half_size.y);
    rotate(angle);
    rect(-half_size.x, -half_size.y, size.x, size.y);
    //noFill();
    //stroke(0, alpha);
    //strokeWeight(1);
    //triangle(-half_size.x, half_size.y, half_size.x, half_size.y, 0, -half_size.y);
    resetMatrix();
    //stroke(color(0, 255, 0));
    //strokeWeight(5);
    //for(int i = 0; i < 4; i++){
    //  point(corners[i].x, corners[i].y);
    //}
    if(show_rays){
      strokeWeight(2);
      stroke(color(255, 0, 255));
      translate(pos.x + half_size.x, pos.y + half_size.y);
      for(int i = 0; i < rays.length; i++){
        line(0, 0, rays[i].x * ray_dists[i], rays[i].y * ray_dists[i]);
      }
    }
    if(control_box_pos != 0){
      textSize(11.75f);
      stroke(0);
      fill(255);
      if(control_box_pos == 1){
        translate(0, 1.5f * size.y);
        rect(-60, -20, 120, 30);
        fill(0);
        text("controls[0]: " + str(truncate(controls[0], 5)), -59, -9);
        text("controls[1]: " + str(truncate(controls[1], 5)), -59, 6);
      } else if(control_box_pos == 2){
        resetMatrix();
        translate(15, map_height - 45);
        rect(0, 0, 120, 30);
        fill(0);
        text("controls[0]: " + str(truncate(controls[0], 5)), 1, -9 + 21);
        text("controls[1]: " + str(truncate(controls[1], 5)), 1, 6 + 21);
      }
    }
  }
}

 public void calcFitness(){
  float sum = 0;
  for(CarBad cb : pop){
    if(world == 2){
      cb.fitness_not_norm = pow(cb.dist_travelled, 2);
    } else {
      cb.fitness_not_norm = pow((cb.max_dist * cb.max_dist) - cb.distsq_to_goal, 1) * .001f * ((cb.num_dir_changes == 0) ? 0 : 1);
      if(cb.finished){
        cb.fitness_not_norm *= 2;
      }
    }
    if(cb.finished){
      //println("finished fitness_not_norm = " + cb.fitness_not_norm);
    } else {
      //println("unfinished fitness_not_norm = " + cb.fitness_not_norm);
    }
    //println(cb.num_dir_changes);
    sum += cb.fitness_not_norm;
  }
  //println("sum = " + sum);
  float fit_sum = 0;
  float inv_sum = 1 / sum;
  for(CarBad cb : pop){
    cb.fitness = cb.fitness_not_norm * inv_sum;
    //println(cb.fitness + ", " + cb.num_dir_changes);
    cb.fitness_w_index = new float[]{cb.fitness, pop.indexOf(cb)};
    //println(cb.fitness);
    if(cb.finished){
      //println("finished fitness = " + cb.fitness);
    } else {
      //println("unfinished fitness = " + cb.fitness);
    }
    fit_sum += cb.fitness;
  }
  //println(sum);
  //println("fit_sum = " + fit_sum);
}

 public CarBad doCrossover(float ma, float mc){ // ma = mutate amt, mc = mutation chance per weight/bias
  int indexA = 0;
  float rnd = random(1);
  while(rnd >= 0){
    if(indexA == popsize){
      indexA--;
    }
    rnd -= pop.get(indexA).fitness;
    indexA++;
  }
  indexA--;
  
  int indexB = 0;
  rnd = random(1);
  while(rnd >= 0){
    if(indexB == popsize){
      indexB--;
    }
    rnd -= pop.get(indexB).fitness;
    indexB++;
  }
  indexB--;
  
  if(indexA != indexB){
    //maybe add
  } else {
    //maybe add
  }
  
  CarBad parentA = pop.get(indexA);
  CarBad parentB = pop.get(indexB);
  parentA.crossover(parentB);
  parentA.mutateNN(ma, mc);
  CarBad newcb = new CarBad(car_spawn_info[0], car_spawn_info[1], car_spawn_info[2], car_spawn_info[3], car_spawn_info[4], parentA.copyNN());
  return newcb;
}

 public CarBad doCrossoverRandom(float ma, float mc, float[] carstopickfrom){
  int indexA = (int)random(carstopickfrom.length);
  int indexB = (int)random(carstopickfrom.length);
  CarBad parentA = pop.get(indexA);
  CarBad parentB = pop.get(indexB);
  parentA.crossover(parentB);
  parentA.mutateNN(ma, mc);
  CarBad newcb = new CarBad(car_spawn_info[0], car_spawn_info[1], car_spawn_info[2], car_spawn_info[3], car_spawn_info[4], parentA.copyNN());
  return newcb;
}

 public float[][] sortPopFitessArray(){
  float[][] pop_fitness_w_index = new float[popsize][2];
  for(int i = 0; i < pop.size(); i++){
    pop_fitness_w_index[i] = pop.get(i).fitness_w_index;
  }
  
  Arrays.sort(pop_fitness_w_index, new Comparator<float[]>() {      
    @Override
    public int compare(float[] o1, float[] o2) {
      return Float.compare(o2[0], o1[0]);
    }
  });
  
  return pop_fitness_w_index;
}

 public int findCarBadIndex(float[][] fitnessarray, int place){ // finds index of car in specific "place", i.e. place 0 is the best car
  
  int index = (int)fitnessarray[place][1];
  return index;
}

 public CarBad pickCarBad(float ma, float mc){ // ma = mutate amt, mc = mutation chance per weight/bias
  int index = 0;
  float rnd = random(1);
  while(rnd > 0){
    if(index == popsize){
      index--;
    }
    rnd -= pop.get(index).fitness;
    index++;
  }
  index--;
  
  CarBad cb = pop.get(index);
  cb.mutateNN(ma, mc);
  CarBad newcb = new CarBad(car_spawn_info[0], car_spawn_info[1], car_spawn_info[2], car_spawn_info[3], car_spawn_info[4], cb.copyNN());
  //newcb.setDefaultColor(color(0));
  //newcb.setColor(color(0));
  return newcb;
}

 public CarBad pickCarBad(float ma, float mc, int index){ // adds car from specific index
  CarBad cb = pop.get(index);
  cb.mutateNN(ma, mc);
  CarBad newcb = new CarBad(car_spawn_info[0], car_spawn_info[1], car_spawn_info[2], car_spawn_info[3], car_spawn_info[4], cb.copyNN());
  newcb.setDefaultColor(color(0));
  newcb.setColor(color(0));
  return newcb;
}

 public void getNextGen(){
  calcFitness();
  float[][] fitnessarray = sortPopFitessArray();
  int best_index = findCarBadIndex(fitnessarray, 0);
  int med_index = findCarBadIndex(fitnessarray, (popsize / 2) - 1); // median
  best_carbads.add(pop.get(best_index));
  best_dists.append(sqrt(pop.get(best_index).distsq_to_goal));
  med_dists.append(sqrt(pop.get(med_index).distsq_to_goal));
  //println(med_dists);
  
  float ma = 1;
  float mc = 1;
  //if(avg_dists.get(avg_dists.size() - 1) <= map_height * .1){
  //  ma *= .25;
  //  mc *= .25;
  //}
  float[] fitnessarray_tomed = getArrayColumn(multiDimSubset(fitnessarray, 0, popsize / 2), 1);
  //println(pop.get((int)fitnessarray_tomed[0]).distsq_to_goal);
  if(alwaysdomedian && med_dists.get(med_dists.size() - 1) < 500){
    if(med_dists.get(med_dists.size() - 1) < map_height * .1f){
      for(int i = 0; i < popsize; i++){
        nextpop.add(doCrossoverRandom(ma * .1f, mc * .1f, fitnessarray_tomed));
        //nextpop.add(pickCarBad(ma, mc));
      }
    } else {  
      for(int i = 0; i < popsize; i++){
        nextpop.add(doCrossoverRandom(ma * .5f, mc * .5f, fitnessarray_tomed));
        //nextpop.add(pickCarBad(ma, mc));
      }
    }
  } else {
    if(domedianwipeout){
      if(med_dists.get(med_dists.size() - 1) < map_height * .1f){
        for(int i = 0; i < popsize; i++){
          println("median finished");
          nextpop.add(doCrossoverRandom(ma * .5f, mc * .5f, fitnessarray_tomed));
          //nextpop.add(pickCarBad(ma, mc));
        }
      } else {
        nextpop.add(pickCarBad(.1f, 0, best_index));
        for(int i = 0; i < popsize - 1; i++){
          //nextpop.add(pickCarBad(.5 * mutationRateFunc(generation), .5 * mutationRateFunc(generation)));
          nextpop.add(doCrossover(ma * .5f, mc * .5f));
          //nextpop.add(pickCarBad(ma, mc));
        }
      }
    } else {
      nextpop.add(pickCarBad(.1f, 0, best_index));
      for(int i = 0; i < popsize - 1; i++){
        //findCarBadIndex(fitnessarray, i);
        //nextpop.add(pickCarBad(.5 * mutationRateFunc(generation), .5 * mutationRateFunc(generation)));
        nextpop.add(doCrossover(ma * .5f, mc * .5f));
        //nextpop.add(pickCarBad(ma, mc));
      }
    }
  }
}

 public float[][] multiDimSubset(float[][] array, int start, int count){
  float[][] temp = new float[count][array[0].length];
  for(int i = start; i < count; i++){
    for(int j = 0; j < temp[0].length; j++){
      //println(i + ", " + j);
      temp[i][j] = array[i][j];
    }  
  }
  return temp;
}

 public float[] getArrayColumn(float[][] array, int col){
  float[] temp = new float[array.length];
  for(int i = 0; i < temp.length; i++){
    temp[i] = array[i][col];
  }
  return temp;
}

 public float mutationRateFunc(float g){ // g is generation
  return .5f * ((1 / sqrt(g)) + (1.5f / (1 + exp(.1733f* (g - 5))))); // the values have been chosen so that at g = 1, its ~1
}
 public Matrix toMatrix(float[][] array){
  Matrix result = new Matrix(array.length, array[0].length);
  result.matrix = array;
  return result;
}

 public Matrix toMatrix(float[] array){
  Matrix result = new Matrix(array.length, 1);
  for(int i = 0; i < array.length; i++){
    result.matrix[i][0] = array[i];
  }
  return result;
}

 public float[] toArray(Matrix mat){ // only for the outputs!
  //mat.printMatrix();
  int[] dims = new int[]{mat.matrix.length, mat.matrix[0].length}; // {rows, cols}
  //println(dims[0] + ", " + dims[1]);
  float[] array;
  if(dims[0] == 1){
    array = new float[mat.matrix.length];
    array = mat.matrix[0];
  } else if(dims[1] == 1){
    array = new float[mat.matrix[0].length];
    array = mat.transpose().matrix[0];
  } else {
    println("Can only be used on a vector!");
    array = new float[]{0}; 
  }
  return array;
}

class Matrix {
  int rows;
  int cols;
  float[][] matrix;
  
  Matrix(int rows, int cols){
    this.rows = rows;
    this.cols = cols;
    matrix = new float[rows][cols];
    
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        matrix[j][i] = 1;
      }
    }
  }
  
   public int getRows(){
    return matrix.length;
  }
  
   public int getCols(){
    return matrix[0].length;
  }
  
   public Matrix copy(){
    Matrix copy = new Matrix(rows, cols);
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        copy.matrix[j][i] = matrix[j][i];
      }
    }
    return copy;
  }
  
   public float sigmoid(float x){
    return 1 / (1 + exp(-x));
  }
  
   public void randomize(float mag){ // ranges from -mag to +mag
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        matrix[j][i] = random(2 * mag) - mag;
      }
    }
  }
  
   public Matrix scalarMult(float scalar){
    Matrix result = new Matrix(rows, cols);
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        result.matrix[j][i] = matrix[j][i] * scalar;
      }
    }
    return result;
  }
  
   public Matrix matrixMult(Matrix m2){
    //println("m1 size:" + str(m1.rows) + ", " + str(m1.cols));
    //println("m2 size:" + str(m2.rows) + ", " + str(m2.cols));
    Matrix result = new Matrix(rows, m2.cols);
    for (int j = 0; j < rows; j++){
      for (int i = 0; i < m2.cols; i++){
        
        float elem = 0;
        for (int e = 0; e < m2.rows; e++){
          //println(e + ", " + j + ", " + i);
          elem += matrix[j][e] * m2.matrix[e][i];
          //print(m1.matrix[j][e] + m2.matrix[e][i]);
        }
        result.matrix[j][i] = elem;
        
      }
    }
    return result;
  }
  
   public Matrix elemMult(Matrix m){
    Matrix result = new Matrix(rows, cols);
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        result.matrix[j][i] = matrix[j][i] * m.matrix[j][i];
      }
    }
    return result;
  }
  
   public Matrix elemAdd(float scalar){
    Matrix result = new Matrix(rows, cols);
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        result.matrix[j][i] = matrix[j][i] + scalar;
      }
    }
    return result;
  }
  
   public Matrix matrixAdd(Matrix m1){
    Matrix result = new Matrix(rows, cols);
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        result.matrix[j][i] = matrix[j][i] + m1.matrix[j][i];
      }
    }
    return result;
  }
  
   public Matrix elemSub(float scalar){
    Matrix result = new Matrix(rows, cols);
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        result.matrix[j][i] = matrix[j][i] - scalar;
      }
    }
    return result;
  }
  
   public Matrix matrixSub(Matrix m1){
    Matrix result = new Matrix(rows, cols);
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        result.matrix[j][i] = matrix[j][i] - m1.matrix[j][i];
      }
    }
    return result;
  }
  
   public Matrix transpose(){
    Matrix transposed = new Matrix(cols, rows); // chaninging dimentions
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        transposed.matrix[i][j] = matrix[j][i];
      }
    }
    return transposed;
  }
  
   public Matrix actFunction(){
    Matrix result = new Matrix(rows, cols);
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        result.matrix[j][i] = sigmoid(matrix[j][i]);
      }
    }
    return result;
  }
  
   public void printMatrix(){
    for(int j = 0; j < rows; j++){
      for(int i = 0; i < cols; i++){
        print(matrix[j][i] + " ");
      }
      println("");
    }
  }
}


class Layer{
  int in_nodes, out_nodes;
  
  Matrix weights;
  Matrix biases;
  
  Layer(int in_nodes, int out_nodes){
    this.in_nodes = in_nodes;
    this.out_nodes = out_nodes;
    
    weights = new Matrix(out_nodes, in_nodes);
    biases = new Matrix(out_nodes, 1);
    
    weights.randomize(3);
    biases.randomize(3);
  }
  
   public Matrix feed(Matrix inputs){
    if(inputs.rows == in_nodes && inputs.cols == 1){
      
    } else if(inputs.rows == 1 && inputs.cols == in_nodes){
      inputs = inputs.transpose();
    } else {
      println("inputs don't have correct dimentions");
      return null;
    }
    return weights.matrixMult(inputs).matrixAdd(biases).actFunction();
  }
  
   public void serialize(FileOutputStream fileout){
    try{
      ObjectOutputStream out = new ObjectOutputStream(fileout);
      out.writeObject(this);
      out.close();
    } catch(IOException i){
      i.printStackTrace();
    }
    
  }
}

class NeuralNetwork2 {
  
  int Inodes;
  int[] Hlayers;
  int num_hiddens;
  int Onodes;
  
  Layer[] layers;
  Matrix[] layer_outs;
  
  int out_layer;
  
  float lr;
  
  NeuralNetwork2(int Inodes, int[] Hlayers, int Onodes, float lr) {
    //println("here!");
    this.lr = lr;
    this.Inodes = Inodes;
    this.Hlayers = Hlayers;
    this.Onodes = Onodes;
    num_hiddens = Hlayers.length;
    out_layer = num_hiddens + 1 - 1;
    // the + 1 - 1 is to show that the length of the array is num_hiddens + 1, 
    // but we need to subtract 1 so we don't go over the end of the array
    layers = new Layer[num_hiddens + 1];
    layer_outs = new Matrix[num_hiddens + 1];
    
    layers[0] = new Layer(Inodes, Hlayers[0]);
    for(int i = 0; i < num_hiddens - 1; i++){
      layers[i + 1] = new Layer(Hlayers[i], Hlayers[i + 1]);
      //println(i + 1 + ",!i, layers!  " + layers[i]);
    }
    layers[num_hiddens + 1 - 1] = new Layer(Hlayers[num_hiddens - 1], Onodes);
  }
  
   public Matrix[] feedForward(Matrix inputs){
    
    layer_outs[0] = layers[0].feed(inputs);
    for(int i = 0; i < out_layer; i++){
      layer_outs[i + 1] = layers[i + 1].feed(layer_outs[i]);
    }
    return layer_outs;
  }
  /*
  I'M NOT BOTHERING WITH BACKPROP RIGHT NOW BECAUSE I'M JUST DOING GENETIC ALGO.
  Matrix[] backProp(Matrix inputs, Matrix targets){
    
    if(inputs.rows == input_nodes && inputs.cols == 1){
      
    } else if(inputs.rows == 1 && inputs.cols == input_nodes){
      inputs = inputs.transpose();
    } else {
      println("inputs don't have correct dimentions");
      return null;
    }
    
    if(targets.rows == output_nodes && targets.cols == 1){
      
    } else if(targets.rows == 1 && targets.cols == output_nodes){
      targets = targets.transpose();
    } else {
      println("targets don't have correct dimentions");
      return null;
    }
    
    Matrix[] from_feed = feedForward(inputs);
    Matrix hiddens = from_feed[0];
    Matrix ys = from_feed[1];
    
    Matrix output_errors = ys.matrixSub(targets);
    Matrix hidden_errors = weights_ho.transpose().matrixMult(output_errors);
    
    Matrix weight_deltas_o, weight_deltas_h, bias_deltas_o, bias_deltas_h;
    
    weight_deltas_o = output_errors.elemMult(ys).elemMult(ys.elemSub(1)).matrixMult(hiddens.transpose()).scalarMult(lr);
    weight_deltas_h = hidden_errors.elemMult(hiddens).elemMult(hiddens.elemSub(1)).matrixMult(inputs.transpose()).scalarMult(lr);
    bias_deltas_o = output_errors.elemMult(ys).elemMult(ys.elemSub(1)).scalarMult(lr);
    bias_deltas_h = hidden_errors.elemMult(hiddens).elemMult(hiddens.elemSub(1)).scalarMult(lr);
    
    //weights_ho.printMatrix();
    //weight_deltas_o.printMatrix();
    
    
    return new Matrix[]{weight_deltas_o, weight_deltas_h, bias_deltas_o, bias_deltas_h};
  }
  */
  
  //Matrix[] backProp(Matrix inputs, Matrix targets){
  //  /*
  //  if(inputs.rows == input_nodes && inputs.cols == 1){
      
  //  } else if(inputs.rows == 1 && inputs.cols == input_nodes){
  //    inputs = inputs.transpose();
  //  } else {
  //    println("inputs don't have correct dimentions");
  //    return null;
  //  }
    
  //  if(targets.rows == output_nodes && targets.cols == 1){
      
  //  } else if(targets.rows == 1 && targets.cols == output_nodes){
  //    targets = targets.transpose();
  //  } else {
  //    println("targets don't have correct dimentions");
  //    return null;
  //  }
  //  */
    
  //  Matrix[] from_feed = feedForward(inputs);
  //  Matrix hiddens = from_feed[0];
  //  Matrix ys = from_feed[1];
    
  //  Matrix output_errors = ys.matrixSub(targets);
  //  Matrix hidden_errors = weights_ho.transpose().matrixMult(output_errors);
    
  //  Matrix weight_deltas_o, weight_deltas_h, bias_deltas_o, bias_deltas_h;
    
  //  weight_deltas_o = output_errors.elemMult(ys).elemMult(ys.elemSub(1)).matrixMult(hiddens.transpose()).scalarMult(lr);
  //  weight_deltas_h = hidden_errors.elemMult(hiddens).elemMult(hiddens.elemSub(1)).matrixMult(inputs.transpose()).scalarMult(lr);
  //  bias_deltas_o = output_errors.elemMult(ys).elemMult(ys.elemSub(1)).scalarMult(lr);
  //  bias_deltas_h = hidden_errors.elemMult(hiddens).elemMult(hiddens.elemSub(1)).scalarMult(lr);
    
  //  //weights_ho.printMatrix();
  //  //weight_deltas_o.printMatrix();
    
    
  //  return new Matrix[]{weight_deltas_o, weight_deltas_h, bias_deltas_o, bias_deltas_h};
  //}

  
   public void mutate(float ma, float mc){ // ma = mutate amt, mc = mutation chance per weight/bias
    //println("checking mutations");
    for(int l = 0; l < out_layer + 1; l++){ // l for layer
      Matrix tempweights = layers[l].weights;
      Matrix tempbiases = layers[l].biases;
      for(int j = 0; j < tempweights.rows; j++){
        for(int i = 0; i < tempweights.cols; i++){
          if(random(1) < mc){
            //println("weight " + l + " " + j + " " + i + " before: " + tempweights.matrix[j][i]);
            tempweights.matrix[j][i] += (random(2) - 1) * ma;
            //println("weight " + l + " " + j + " " + i + " after: " + tempweights.matrix[j][i]);
          }
        }
      }
      
      for(int j = 0; j < tempbiases.rows; j++){
        for(int i = 0; i < tempbiases.cols; i++){
          if(random(1) < mc){
            //println("bias " + l + " " + j + " " + i + " before: " + tempbiases.matrix[j][i]);
            tempbiases.matrix[j][i] += (random(2) - 1) * ma;
            //println("bias " + l + " " + j + " " + i + " after: " + tempbiases.matrix[j][i]);
          }
        }
      }
      layers[l].weights = tempweights;
      layers[l].biases = tempbiases;
    }
  }
  
   public void crossover(NeuralNetwork2 parent){
    for(int l = 0; l < out_layer + 1; l++){ // l for layer
      Matrix tempweights = layers[l].weights;
      Matrix tempbiases = layers[l].biases;
      Matrix pweights = parent.layers[l].weights;
      Matrix pbiases = parent.layers[l].biases;
      for(int j = 0; j < tempweights.rows; j++){
        for(int i = 0; i < tempweights.cols; i++){
          if(random(1) < .5f){
            tempweights.matrix[j][i] = pweights.matrix[j][i];
          }
        }
      }
      
      for(int j = 0; j < tempbiases.rows; j++){
        for(int i = 0; i < tempbiases.cols; i++){
          if(random(1) < .5f){
            tempbiases.matrix[j][i] = pbiases.matrix[j][i];
          }
        }
      }
      layers[l].weights = tempweights;
      layers[l].biases = tempbiases;
    }
  }
  /*
  void train(Matrix inputs, Matrix targets){
    
    Matrix[] from_backprop = backProp(inputs, targets);
    Matrix weight_deltas_o = from_backprop[0];
    Matrix weight_deltas_h = from_backprop[1];
    Matrix bias_deltas_o = from_backprop[2];
    Matrix bias_deltas_h = from_backprop[3];
    
    weights_ho = weights_ho.matrixAdd(weight_deltas_o);
    weights_ih = weights_ih.matrixAdd(weight_deltas_h);
    biases_ho = biases_ho.matrixAdd(bias_deltas_o);
    biases_ih = biases_ih.matrixAdd(bias_deltas_h);
  }
  */
   public Matrix check(Matrix inputs){
    Matrix[] from_feed = feedForward(inputs);
    Matrix outputs = from_feed[out_layer];
    return outputs;
  }
  
   public NeuralNetwork2 copyNN(){
    NeuralNetwork2 nn2copy = new NeuralNetwork2(Inodes, Hlayers, Onodes, lr);
    for(int l = 0; l < out_layer + 1; l++){ // l for layer
      Matrix tempweights = layers[l].weights;
      Matrix tempbiases = layers[l].biases;
      for(int j = 0; j < tempweights.rows; j++){
        for(int i = 0; i < tempweights.cols; i++){
          nn2copy.layers[l].weights.matrix[j][i] = layers[l].weights.matrix[j][i];
        }
      }
      for(int j = 0; j < tempbiases.rows; j++){
        for(int i = 0; i < tempbiases.cols; i++){
          nn2copy.layers[l].biases.matrix[j][i] = layers[l].biases.matrix[j][i];
        }
      }
    }
    return nn2copy;
  }
  
   public void serialize(String filename){
    try{
      FileOutputStream fileout = new FileOutputStream(filename);
      //ObjectOutputStream out = new ObjectOutputStream(fileout);
      //out.writeObject(this);
      //out.close();
      for(int l = 0; l < layers.length; l++){
        layers[l].serialize(fileout);
        //ObjectOutputStream out = new ObjectOutputStream(fileout);
      }
      fileout.close();
    } catch(IOException i){
      i.printStackTrace();
    }
  }
}


 public void drawWorld(){
  if(world == 0){
    boxes.add(new Box(10, 10, 100, 10, 0));
    boxes.add(new Box(10, 10, 100, 10, HALF_PI));
    boxes.add(new Box(120, 10, 100, 10, HALF_PI));
    
    boxes.add(new Box(10, 110, 100, 10, HALF_PI));
    boxes.add(new Box(120, 110, 100, 10, HALF_PI));
    
    boxes.add(new Box(10, 210, 100, 10, HALF_PI - .1f));
    boxes.add(new Box(120, 210, 100, 10, HALF_PI - .1f));
    
    boxes.add(new Box(10 + 9, 310, 100, 10, HALF_PI - .2f));
    boxes.add(new Box(120 + 9, 310, 100, 10, HALF_PI - .2f));
  } else if(world == 1){
    for(int i = 0; i < 40; i++){
      boxes.add(new Box(random(map_width), random(map_height * 1) + map_height * .0f, (random(20) + 10) * 5, (random(20) + 10) * 5, random(TWO_PI)));
    }
    Box spawn_mask = new Box(150, 350, 150, 100, 0); // covers spawn area to make sure cars aren't immediately collided
    Box goal_mask = new Box(1100, 320, 100, 160, 0);
    for(int i = boxes.size() - 1; i >= 0; i--){ // checking collisions with the spawn mask
      Box b = boxes.get(i);
      if(spawn_mask.checkBoxCollision(spawn_mask, b)){
        boxes.remove(b);
      } else if (b.checkBoxCollision(b, spawn_mask)){
        boxes.remove(b);
      } else if (goal_mask.checkBoxCollision(goal_mask, b)){
        boxes.remove(b);
      } else if (b.checkBoxCollision(b, goal_mask)){
        boxes.remove(b);
      }
    }
    spawn_mask = null;
    goal_mask = null;
    boxes.add(new Box(0, map_height - 10, map_width, 10, 0));
    boxes.add(new Box(0, 0, 2 * map_width / 5, 10, 0));
    boxes.add(new Box(3 * map_width / 5, 0, 2 * map_width / 5, 10, 0));
    boxes.add(new Box(0, 0, 10, map_height, 0));
    boxes.add(new Box(map_width - 10, 0, 10, map_height, 0));
  } else if(world == 2){
    for(int i = 0; i < 40; i++){
      boxes.add(new Box(random(map_width), random(map_height * 1) + map_height * .0f, (random(20) + 10) * 5, (random(20) + 10) * 5, random(TWO_PI)));
    }
    Box spawn_mask = new Box(150, 350, 150, 100, 0); // covers spawn area to make sure cars aren't immediately collided
    for(int i = boxes.size() - 1; i >= 0; i--){ // checking collisions with the spawn mask
      Box b = boxes.get(i);
      if(spawn_mask.checkBoxCollision(spawn_mask, b)){
        boxes.remove(b);
      } else if (b.checkBoxCollision(b, spawn_mask)){
        boxes.remove(b);
      }
    }
    spawn_mask = null;
    //boxes.add(new Box(600, 400, 100, 100, 0)); testing
    boxes.add(new Box(0, 0, map_width, 10, 0));
    boxes.add(new Box(0, map_height - 10, map_width, 10, 0));
    boxes.add(new Box(0, 0, 10, map_height, 0));
    boxes.add(new Box(map_width - 10, 0, 10, map_height, 0));
  } else if(world == 3){
    boxes.add(new Box(0, 0, map_width, 10, 0));
    boxes.add(new Box(0, map_height - 10, map_width, 10, 0));
    boxes.add(new Box(0, 0, 10, map_height, 0));
    boxes.add(new Box(map_width - 10, 0, 10, map_height, 0));
  } else if(world == 4){
    for(int i = 0; i < 30; i++){ // i < 25 works well
      world4BoxSpawner(0);
    }
    
    goal_y_center = random(map_height * .1f + 10, map_height * .9f - 10);
    goal_pos = new PVector(map_width, goal_y_center);
    //50, 395, 10, 25, HALF_PI
    Box spawn_mask = new Box(-100, car_spawn_info[1] - 70, 300, 150, 0); // covers spawn area to make sure cars aren't immediately collided
    Box goal_mask = new Box(map_width - 100, goal_y_center - map_height * .1f, 200, map_height * .2f, 0);
    spawn_mask.c = color(255, 0, 0);
    goal_mask.c = color(255, 0, 0);
    for(int i = boxes.size() - 1; i >= 0; i--){ // checking collisions with the spawn mask
      Box b = boxes.get(i);
      if(spawn_mask.checkBoxCollision(spawn_mask, b)){
        boxes.remove(b);
      } else if (b.checkBoxCollision(b, spawn_mask)){
        boxes.remove(b);
      } else if (goal_mask.checkBoxCollision(goal_mask, b)){
        boxes.remove(b);
      } else if (b.checkBoxCollision(b, goal_mask)){
        boxes.remove(b);
      }
    }
    spawn_mask = null;
    goal_mask = null;
    
    //Box goal = new Box(1200 - 10, goal_y_center - map_height * .1, 20, map_height * .2, 0);
    //goal.c = color(255, 255, 255);
    //goal.collidable = false;
    //boxes.add(goal);
    
    boxes.add(new Box(0, 0, map_width, 10, 0));
    boxes.add(new Box(0, map_height - 10, map_width, 10, 0));
    boxes.add(new Box(0, 0, 10, map_height, 0));
    boxes.add(new Box(map_width - 10, 0, 10, goal_y_center - map_height * .1f, 0));
    boxes.add(new Box(map_width - 10, goal_y_center + map_height * .1f, 10, map_height * .9f - goal_y_center, 0));
    //while(!stopped){
    //  spawn_mask.show();
    //  goal_mask.show();
    //  for(Box b : boxes){
    //    b.show();
    //  }
    //}
    
    
  }
}

 public void world4BoxSpawner(int counter){
  if(boxes.size() == 0){
    boxes.add(new Box(random(map_width), random(map_height), (random(2) + 1) * 50, (random(2) + 1) * 50, random(TWO_PI)));
  } else {
    float x, y, w, h;
    x = random(map_width);
    y = random(map_height);
    w = (random(2) + 1) * 50;
    h = (random(2) + 1) * 50;
    Box bnew = new Box(x, y, w, h, random(TWO_PI));
    boolean can_add = true;
    for(Box b : boxes){
      if(bnew.center.copy().sub(b.center).magSq() <= (.25f * (w + b.size.x + 15) * (w + b.size.x + 15)) + (.25f * (h + b.size.y + 15) * (h + b.size.y + 15))){
        can_add = false;
      }
    }
    //for loop ends
    if(can_add){
      boxes.add(bnew);
    } else {
      if(counter < 50){
        world4BoxSpawner(counter + 1);
      }
    }
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "carsdriving2" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
